#!/bin/bash
# =============================================================================
# Offline Deployment Script for Ultimate K8s Toolbox
# =============================================================================
# This script deploys the Ultimate K8s Toolbox in an offline/air-gapped
# environment. It handles image loading, registry pushing, and optional
# CA certificate import.
#
# Usage:
#   ./deploy-offline.sh [OPTIONS]
#
# Options:
#   --registry <url>           Internal registry URL (default: myregistry.local:5000)
#   --namespace <ns>           Kubernetes namespace (default: toolbox)
#   --release-name <name>      Helm release name (default: offline-toolbox)
#   --root-ca <path>           Path to root CA certificate
#   --subordinate-ca <path>    Path to subordinate CA certificate
#   --ca-secret-name <name>    CA secret name (default: toolbox-ca-certs)
#   --skip-ca-prompt           Skip interactive CA certificate prompts
#   --skip-registry-push       Skip pushing to registry (image already there)
#   --dry-run                  Show what would be done without executing
#   --help                     Show this help message
#
# Environment Variables (alternative to flags):
#   REGISTRY                   Internal registry URL
#   NAMESPACE                  Kubernetes namespace
#   RELEASE_NAME               Helm release name
#   ROOT_CA_PATH               Path to root CA certificate
#   SUBORDINATE_CA_PATH        Path to subordinate CA certificate
#   CA_SECRET_NAME             CA secret name
#
# Examples:
#   ./deploy-offline.sh --registry harbor.internal.com/platform
#   ./deploy-offline.sh --root-ca /certs/root-ca.crt --subordinate-ca /certs/sub-ca.crt
#   REGISTRY=nexus:8082 ./deploy-offline.sh --skip-ca-prompt
# =============================================================================

set -e

# Colors for output
COLOR_GREEN='\033[32m'
COLOR_RED='\033[31m'
COLOR_YELLOW='\033[1;33m'
COLOR_CYAN='\033[36m'
COLOR_RESET='\033[0m'

# Functions for output
print_header() {
    echo ""
    echo -e "${COLOR_CYAN}========================================"
    echo -e "  $1"
    echo -e "========================================${COLOR_RESET}"
    echo ""
}

print_success() { echo -e "${COLOR_GREEN}✓ $1${COLOR_RESET}"; }
print_error() { echo -e "${COLOR_RED}✗ $1${COLOR_RESET}"; }
print_warning() { echo -e "${COLOR_YELLOW}⚠ $1${COLOR_RESET}"; }
print_info() { echo -e "${COLOR_CYAN}ℹ $1${COLOR_RESET}"; }

# Default configuration (can be overridden by environment variables or flags)
REGISTRY=${REGISTRY:-"kuberegistry.k8.cantrellcloud.net:8443/library"}
NAMESPACE=${NAMESPACE:-"toolbox"}
RELEASE_NAME=${RELEASE_NAME:-"toolbox"}
IMAGE_REPO=${IMAGE_REPO:-"ultimate-k8s-toolbox"}
IMAGE_TAG=${IMAGE_TAG:-"v1.0.1"}
CA_SECRET_NAME=${CA_SECRET_NAME:-"toolbox-ca-certs"}
ROOT_CA_PATH=${ROOT_CA_PATH:-""}
SUBORDINATE_CA_PATH=${SUBORDINATE_CA_PATH:-""}
SKIP_CA_PROMPT=true
SKIP_REGISTRY_PUSH=false
DRY_RUN=false
ENABLE_CA=true

# Show help
show_help() {
    head -40 "$0" | tail -35 | sed 's/^# //' | sed 's/^#//'
    exit 0
}

# Parse command line arguments
parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            --registry)
                REGISTRY="$2"
                shift 2
                ;;
            --namespace)
                NAMESPACE="$2"
                shift 2
                ;;
            --release-name)
                RELEASE_NAME="$2"
                shift 2
                ;;
            --root-ca)
                ROOT_CA_PATH="$2"
                ENABLE_CA=true
                shift 2
                ;;
            --subordinate-ca)
                SUBORDINATE_CA_PATH="$2"
                ENABLE_CA=true
                shift 2
                ;;
            --ca-secret-name)
                CA_SECRET_NAME="$2"
                shift 2
                ;;
            --skip-ca-prompt)
                SKIP_CA_PROMPT=true
                shift
                ;;
            --skip-registry-push)
                SKIP_REGISTRY_PUSH=true
                shift
                ;;
            --dry-run)
                DRY_RUN=true
                shift
                ;;
            --help|-h)
                show_help
                ;;
            *)
                print_error "Unknown option: $1"
                echo "Use --help for usage information"
                exit 1
                ;;
        esac
    done
}

# Validate certificate file
validate_certificate() {
    local cert_path="$1"
    local cert_name="$2"
    
    if [ ! -f "$cert_path" ]; then
        print_error "Certificate file not found: $cert_path"
        return 1
    fi
    
    if ! openssl x509 -in "$cert_path" -noout 2>/dev/null; then
        print_error "Invalid certificate format: $cert_path"
        return 1
    fi
    
    local subject expiry
    subject=$(openssl x509 -in "$cert_path" -noout -subject 2>/dev/null | sed 's/subject=//')
    expiry=$(openssl x509 -in "$cert_path" -noout -enddate 2>/dev/null | sed 's/notAfter=//')
    
    print_success "$cert_name certificate validated"
    echo "    Subject: $subject"
    echo "    Expires: $expiry"
    
    # Check expiration
    if ! openssl x509 -in "$cert_path" -noout -checkend 0 2>/dev/null; then
        print_error "Certificate is EXPIRED!"
        return 1
    fi
    
    return 0
}

# Prompt for CA certificates (interactive)
prompt_ca_certificates() {
    if [ "$SKIP_CA_PROMPT" = true ]; then
        return 0
    fi
    
    echo ""
    read -r -p "Do you want to import CA certificates for the toolbox? [y/N]: " import_ca
    
    if [[ ! "$import_ca" =~ ^[Yy]$ ]]; then
        print_info "Skipping CA certificate import"
        return 0
    fi
    
    ENABLE_CA=true
    
    echo ""
    read -r -p "Enter path to root CA certificate (or press Enter to skip): " ROOT_CA_PATH
    if [ -n "$ROOT_CA_PATH" ]; then
        ROOT_CA_PATH="${ROOT_CA_PATH/#\~/$HOME}"
    fi
    
    read -r -p "Enter path to subordinate/intermediate CA certificate (or press Enter to skip): " SUBORDINATE_CA_PATH
    if [ -n "$SUBORDINATE_CA_PATH" ]; then
        SUBORDINATE_CA_PATH="${SUBORDINATE_CA_PATH/#\~/$HOME}"
    fi
    
    read -r -p "Enter CA secret name [$CA_SECRET_NAME]: " input_secret
    [ -n "$input_secret" ] && CA_SECRET_NAME="$input_secret"
}

# Create CA secret
create_ca_secret() {
    if [ "$ENABLE_CA" != true ]; then
        return 0
    fi
    
    if [ -z "$ROOT_CA_PATH" ] && [ -z "$SUBORDINATE_CA_PATH" ]; then
        print_warning "CA import enabled but no certificates provided"
        return 0
    fi
    
    print_header "Importing CA Certificates"
    
    # Validate certificates
    local validation_failed=false
    
    if [ -n "$ROOT_CA_PATH" ]; then
        if ! validate_certificate "$ROOT_CA_PATH" "Root CA"; then
            validation_failed=true
        fi
    fi
    
    if [ -n "$SUBORDINATE_CA_PATH" ]; then
        if ! validate_certificate "$SUBORDINATE_CA_PATH" "Subordinate CA"; then
            validation_failed=true
        fi
    fi
    
    if [ "$validation_failed" = true ]; then
        print_error "Certificate validation failed"
        exit 1
    fi
    
    echo ""
    
    # Build secret creation command
    local secret_args=()
    
    if [ -n "$ROOT_CA_PATH" ]; then
        secret_args+=("--from-file=root-ca.crt=$ROOT_CA_PATH")
    fi
    
    if [ -n "$SUBORDINATE_CA_PATH" ]; then
        secret_args+=("--from-file=subordinate-ca.crt=$SUBORDINATE_CA_PATH")
    fi
    
    # Create combined CA bundle
    local bundle_file
    bundle_file=$(mktemp)
    [ -n "$ROOT_CA_PATH" ] && cat "$ROOT_CA_PATH" >> "$bundle_file"
    [ -n "$ROOT_CA_PATH" ] && echo "" >> "$bundle_file"
    [ -n "$SUBORDINATE_CA_PATH" ] && cat "$SUBORDINATE_CA_PATH" >> "$bundle_file"
    secret_args+=("--from-file=ca-bundle.crt=$bundle_file")
    
    if [ "$DRY_RUN" = true ]; then
        print_info "DRY RUN: Would create CA secret:"
        echo "  kubectl create secret generic $CA_SECRET_NAME ${secret_args[*]} -n $NAMESPACE"
        rm -f "$bundle_file"
        return 0
    fi
    
    # Delete existing secret if it exists
    if kubectl get secret "$CA_SECRET_NAME" -n "$NAMESPACE" &>/dev/null; then
        print_info "Updating existing CA secret: $CA_SECRET_NAME"
        kubectl delete secret "$CA_SECRET_NAME" -n "$NAMESPACE"
    fi
    
    # Create the secret
    print_info "Creating CA secret: $CA_SECRET_NAME"
    kubectl create secret generic "$CA_SECRET_NAME" "${secret_args[@]}" -n "$NAMESPACE"
    
    rm -f "$bundle_file"
    
    print_success "CA secret created: $CA_SECRET_NAME"
}

# Check prerequisites
check_prerequisites() {
    print_info "Checking prerequisites..."
    
    local missing=false
    
    if ! command -v docker &>/dev/null && ! command -v podman &>/dev/null; then
        print_error "docker or podman not found"
        missing=true
    fi
    
    if ! command -v helm &>/dev/null; then
        print_error "helm not found"
        missing=true
    fi
    
    if ! command -v kubectl &>/dev/null; then
        print_error "kubectl not found"
        missing=true
    fi
    
    if ! command -v openssl &>/dev/null; then
        print_warning "openssl not found (CA validation will be skipped)"
    fi
    
    if [ "$missing" = true ]; then
        exit 1
    fi
    
    print_success "All prerequisites installed"
}

# Load Docker image
load_image() {
    print_header "Loading Docker Images"
    
    for image_tar in ../images/*.tar; do
        if [ -f "$image_tar" ]; then
            print_info "Loading $image_tar"
            if [ "$DRY_RUN" = true ]; then
                print_info "DRY RUN: Would load $image_tar"
            else
                docker load -i "$image_tar"
            fi
            print_success "Image loaded"
        fi
    done
}

# Push to registry
push_to_registry() {
    if [ "$SKIP_REGISTRY_PUSH" = true ]; then
        print_info "Skipping registry push (--skip-registry-push)"
        return 0
    fi
    
    print_header "Pushing to Internal Registry"
    
    print_info "Tagging image for $REGISTRY"
    
    if [ "$DRY_RUN" = true ]; then
        print_info "DRY RUN: Would tag and push to $REGISTRY/${IMAGE_REPO}:${IMAGE_TAG}"
        return 0
    fi
    
    docker tag "${IMAGE_REPO}:${IMAGE_TAG}" "$REGISTRY/${IMAGE_REPO}:${IMAGE_TAG}"
    docker tag "${IMAGE_REPO}:${IMAGE_TAG}" "$REGISTRY/${IMAGE_REPO}:latest"
    
    print_info "Pushing to registry (this may take a while)..."
    docker push "$REGISTRY/${IMAGE_REPO}:${IMAGE_TAG}"
    docker push "$REGISTRY/${IMAGE_REPO}:latest"
    
    print_success "Images pushed to registry"
}

# Create namespace
create_namespace() {
    print_header "Creating Namespace"
    
    if [ "$DRY_RUN" = true ]; then
        print_info "DRY RUN: Would create namespace $NAMESPACE"
        return 0
    fi
    
    kubectl create namespace "$NAMESPACE" --dry-run=client -o yaml | kubectl apply -f -
    print_success "Namespace $NAMESPACE ready"
}

# Deploy with Helm
deploy_helm() {
    print_header "Deploying with Helm"
    
    # Build helm command
    local helm_args=()
    helm_args+=(upgrade --install "$RELEASE_NAME")
    helm_args+=(../charts/ultimate-k8s-toolbox-*.tgz)
    helm_args+=(--set "global.imageRegistry=$REGISTRY")
    helm_args+=(--set "image.repository=$IMAGE_REPO")
    helm_args+=(--set "image.tag=$IMAGE_TAG")
    helm_args+=(--namespace "$NAMESPACE")
    
    # Add CA configuration if enabled
    if [ "$ENABLE_CA" = true ] && { [ -n "$ROOT_CA_PATH" ] || [ -n "$SUBORDINATE_CA_PATH" ]; }; then
        helm_args+=(--set "customCA.enabled=true")
        helm_args+=(--set "customCA.secretName=$CA_SECRET_NAME")
    fi
    
    helm_args+=(--wait --timeout 5m)
    
    if [ "$DRY_RUN" = true ]; then
        print_info "DRY RUN: Would execute:"
        echo "  helm ${helm_args[*]}"
        return 0
    fi
    
    helm "${helm_args[@]}"
    
    print_success "Deployment complete!"
}

# Show deployment info
show_deployment_info() {
    print_header "Deployment Information"
    
    if [ "$DRY_RUN" = true ]; then
        print_info "DRY RUN: Would show deployment information"
        return 0
    fi
    
    kubectl get all -n "$NAMESPACE"
    
    echo ""
    print_success "Ultimate K8s Toolbox deployed successfully!"
    echo ""
    echo "To access the toolbox:"
    echo "  kubectl -n $NAMESPACE exec -it deploy/${RELEASE_NAME}-ultimate-k8s-toolbox -- bash"
    echo ""
    
    if [ "$ENABLE_CA" = true ]; then
        echo "CA certificates:"
        echo "  - Mounted at: /etc/ssl/custom-ca/"
        echo "  - Trusted in: /etc/ssl/certs/ca-certificates.crt"
        echo ""
        echo "  The init container ran 'update-ca-certificates' as root to add your"
        echo "  CA certificates to the system trust store. All tools (curl, wget,"
        echo "  Python requests, mongosh, etc.) will trust these certificates."
        echo ""
        echo "  To verify CA trust inside the pod:"
        echo "    curl -v https://your-internal-service/"
        echo ""
    fi
}

# Main execution
main() {
    print_header "Ultimate K8s Toolbox - Offline Deployment"
    
    # Parse command line arguments
    parse_args "$@"
    
    # Show configuration
    echo "Configuration:"
    echo "  Registry:     $REGISTRY"
    echo "  Namespace:    $NAMESPACE"
    echo "  Release:      $RELEASE_NAME"
    echo "  Image:        $IMAGE_REPO:$IMAGE_TAG"
    [ "$DRY_RUN" = true ] && echo "  Mode:         DRY RUN"
    echo ""
    
    # Check prerequisites
    check_prerequisites
    
    # Prompt for CA certificates if not provided
    prompt_ca_certificates
    
    # Load image
    load_image
    
    # Push to registry
    push_to_registry
    
    # Create namespace
    create_namespace
    
    # Create CA secret if certificates provided
    create_ca_secret
    
    # Deploy with Helm
    deploy_helm
    
    # Show deployment info
    show_deployment_info
}

# Run main function
main "$@"
